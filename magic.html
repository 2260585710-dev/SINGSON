<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>流光纹样 (黄金版)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; }
        
        #ui-container {
            position: absolute; top: 20px; left: 20px;
            color: #ffd700; z-index: 100;
            text-shadow: 0 0 5px #ffd700;
            pointer-events: none;
        }
        
        #loading {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: #ffd700; font-size: 18px;
            pointer-events: none;
            border: 1px solid #ffd700;
            padding: 10px 20px;
            border-radius: 5px;
            background: rgba(0,0,0,0.8);
        }
        
        .input_video { display: none; }
    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
</head>
<body>

    <div id="ui-container">
        <h3>✨ 流光纹样</h3>
        <p style="font-size:12px; opacity:0.8;">如果是黑屏，请检查文件名是否为 overlay.png</p>
    </div>

    <div id="loading">正在提取光点...</div>
    <video class="input_video"></video>

    <script>
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
        camera.position.z = 180;

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        let particles;
        let originalPositions = [];
        let randomTargets = [];
        
        // 1. 先创建一个“备用”的立方体，防止图片加载失败啥都看不见
        // 如果你看到屏幕上有个红色的方块，说明3D功能是好的，只是图片没读到
        const debugGeo = new THREE.BoxGeometry(10, 10, 10);
        const debugMat = new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true });
        const debugMesh = new THREE.Mesh(debugGeo, debugMat);
        debugMesh.position.set(0, -50, 0); // 放在下面一点
        // scene.add(debugMesh); // 取消注释这行可以看到调试方块

        const img = new Image();
        img.src = './overlay.png'; // ⚠️ 再次确认文件名
        img.crossOrigin = "Anonymous";

        img.onload = function() {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            const targetWidth = 300; 
            const scale = targetWidth / img.width; 
            canvas.width = targetWidth;
            canvas.height = img.height * scale;
            
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imgData.data;

            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            
            // 金色 (Gold)
            const baseColor = new THREE.Color(0xffd700); 

            let count = 0;
            for (let y = 0; y < canvas.height; y++) {
                for (let x = 0; x < canvas.width; x++) {
                    const i = (y * canvas.width + x) * 4;
                    const alpha = data[i + 3];

                    // 只要有一点不透明，就生成粒子
                    if (alpha > 10) {
                        const pX = (x - canvas.width / 2) * 1.2; // 稍微拉开一点间距
                        const pY = -(y - canvas.height / 2) * 1.2;
                        const pZ = 0;

                        positions.push(pX, pY, pZ);
                        originalPositions.push(pX, pY, pZ);

                        randomTargets.push(
                            (Math.random() - 0.5) * 400,
                            (Math.random() - 0.5) * 400,
                            (Math.random() - 0.5) * 400
                        );

                        // ⚠️ 强制染色！无视原图颜色
                        // 随机一点点亮度变化，让它闪烁
                        const variance = Math.random() * 0.5 + 0.5;
                        colors.push(baseColor.r * variance, baseColor.g * variance, baseColor.b * variance);
                        
                        count++;
                    }
                }
            }

            console.log("生成的粒子数量:", count);
            if (count === 0) {
                alert("警告：图片读取到了，但没有提取到像素点！请检查图片是不是纯透明的？");
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            const material = new THREE.PointsMaterial({
                size: 1.5,
                vertexColors: true,
                transparent: true,
                opacity: 1.0, 
                blending: THREE.AdditiveBlending, // 发光模式
                depthWrite: false
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);
            
            document.getElementById('loading').style.display = 'none';
        };
        
        // 假如图片加载失败
        img.onerror = function() {
            alert("图片加载失败！请检查 overlay.png 是否存在，或者文件名大小写是否正确。");
            document.getElementById('loading').innerText = "❌ 图片加载失败";
        }

        // --- 手势 ---
        let handOpenness = 0; 
        
        function onResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                const dist = Math.sqrt(Math.pow(landmarks[4].x - landmarks[8].x, 2) + Math.pow(landmarks[4].y - landmarks[8].y, 2));
                handOpenness = Math.max(0, Math.min(1, (dist - 0.04) * 3));
            } else {
                handOpenness *= 0.9;
            }
        }

        function animate() {
            requestAnimationFra
