<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>é«˜æ¸…ç»†èŠ‚å¹³è¡¡ç‰ˆ</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; }
        #ui {
            position: absolute; bottom: 30px; left: 20px;
            color: rgba(255,255,255,0.8); pointer-events: none;
            background: rgba(0,0,0,0.6); padding: 12px; border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.1);
        }
        #loading {
            position: absolute; top: 50%; left: 50%; 
            transform: translate(-50%, -50%);
            color: #0ff; font-size: 16px;
            pointer-events: none;
            text-align: center;
            line-height: 1.5;
            text-shadow: 0 0 10px #0ff;
        }
        .input_video { display: none; }
    </style>
    <!-- æ ¸å¿ƒåº“ -->
    <script src="https://unpkg.com/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
</head>
<body>

    <div id="loading">æ­£åœ¨åŠ è½½çº¹æ ·...<br><span style="font-size:12px; color:#666">å¦‚æœä¸åŠ¨è¯·åˆ·æ–°</span></div>
    
    <div id="ui">
        <b style="color:#fff">ğŸ–ï¸ äº¤äº’æ§åˆ¶</b><br>
        <span style="font-size:12px;">å¼ å¼€æ‰‹æŒï¼šç²’å­æ‰©æ•£</span><br>
        <span style="font-size:12px;">æ¡ç´§æ‹³å¤´ï¼šçº¹æ ·è¿˜åŸ</span>
    </div>

    <video class="input_video"></video>

    <script>
        const imageSrc = "./overlay.png"; // ç¡®ä¿æ–‡ä»¶åæ­£ç¡®

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
        camera.position.z = 160; // ç¨å¾®æ‹‰è¿‘é•œå¤´ï¼Œçœ‹ç»†èŠ‚

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // é™åˆ¶åƒç´ æ¯”ï¼Œé˜²æ­¢é«˜åˆ†å±æ‰‹æœºå¡æ­»
        document.body.appendChild(renderer.domElement);

        let particles;
        let originalPositions = [];
        let randomTargets = [];
        let handOpenness = 0;

        const img = new Image();
        img.crossOrigin = "Anonymous";
        img.src = imageSrc;

        img.onload = function() {
            try {
                document.getElementById('loading').innerText = "æ­£åœ¨ç”Ÿæˆé«˜å¯†åº¦ç²’å­...";
                
                // --- âš¡ï¸ æ€§èƒ½ä¼˜åŒ–çš„å…³é”® ---
                // ä½¿ç”¨ setTimeout è®© UI æœ‰æœºä¼šåˆ·æ–°æ–‡å­—ï¼Œé¿å…æµè§ˆå™¨å‡æ­»
                setTimeout(() => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    // ğŸŒŸ 320 æ˜¯æ‰‹æœºæ€§èƒ½çš„å¹³è¡¡ç‚¹ï¼Œæ—¢æ¸…æ™°åˆæµç•…
                    const targetWidth = 320; 
                    const scale = targetWidth / img.width;
                    canvas.width = targetWidth;
                    canvas.height = img.height * scale;
                    
                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                    const data = ctx.getImageData(0, 0, canvas.width, canvas.height).data;

                    const geometry = new THREE.BufferGeometry();
                    const positions = [];
                    const colors = [];
                    const colorVar = new THREE.Color();

                    for (let y = 0; y < canvas.height; y++) {
                        for (let x = 0; x < canvas.width; x++) {
                            const i = (y * canvas.width + x) * 4;
                            const alpha = data[i + 3];

                            if (alpha > 20) { // ç¨å¾®æé«˜ä¸€ç‚¹é˜ˆå€¼ï¼Œè¿‡æ»¤æ‚è¾¹
                                // åæ ‡è®¡ç®—
                                const pX = (x - canvas.width / 2) * 1.1; // 1.1å€é—´è·ï¼Œè®©ç”»é¢æ’‘å¾—æ›´å¤§
                                const pY = -(y - canvas.height / 2) * 1.1;
                                const pZ = 0;

                                positions.push(pX, pY, pZ);
                                originalPositions.push(pX, pY, pZ);
                                
                                // çˆ†ç‚¸èŒƒå›´
                                randomTargets.push(
                                    (Math.random()-0.5)*450, 
                                    (Math.random()-0.5)*450, 
                                    (Math.random()-0.5)*300
                                );
                                
                                // ğŸ¨ é¢œè‰²å¤„ç†ï¼šåŸè‰² + é€‚åº¦æäº®
                                colorVar.setRGB(data[i]/255, data[i+1]/255, data[i+2]/255);
                                // æäº® 20%ï¼Œæ—¢ä¿ç•™ç»†èŠ‚åˆä¸æš—
                                colorVar.multiplyScalar(1.2); 
                                
                                colors.push(colorVar.r, colorVar.g, colorVar.b);
                            }
                        }
                    }

                    if (positions.length === 0) {
                        throw new Error("æ²¡æœ‰æå–åˆ°åƒç´ ï¼Œå¯èƒ½æ˜¯å›¾ç‰‡å…¨é€æ˜ï¼Ÿ");
                    }

                    geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                    geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

                    const material = new THREE.PointsMaterial({
                        size: 0.9, // ç²’å­å¤§å°ï¼š0.9 æ¯”è¾ƒç»†è…»
                        vertexColors: true,
                        transparent: true,
                        opacity: 1.0, // ä¸é€æ˜ï¼Œä¿è¯æ¸…æ™°åº¦
                        blending: THREE.NormalBlending, // æ­£å¸¸æ··åˆï¼Œè¿˜åŸçœŸå®è‰²å½©
                        depthTest: false
                    });

                    particles = new THREE.Points(geometry, material);
                    scene.add(particles);
                    
                    document.getElementById('loading').style.display = 'none';
                }, 100); // å»¶æ—¶ 100ms æ‰§è¡Œ

            } catch (e) {
                document.getElementById('loading').innerText = "å‡ºé”™: " + e.message;
                document.getElementById('loading').style.color = "red";
            }
        };

        img.onerror = function() {
            document.getElementById('loading').innerText = "å›¾ç‰‡åŠ è½½å¤±è´¥ (404)\nè¯·æ£€æŸ¥ overlay.png";
            document.getElementById('loading').style.color = "red";
        }

        // åŠ¨ç”»å¾ªç¯
        function animate() {
            requestAnimationFrame(animate);
            if (particles) {
                const pos = particles.geometry.attributes.position.array;
                
                // é»˜è®¤å‘¼å¸æ•ˆæœ
                let factor = handOpenness;
                if (factor === 0) {
                     factor = Math.sin(Date.now() * 0.0015) * 0.03 + 0.03;
                }

                for (let i = 0; i < pos.length; i += 3) {
                    const tx = originalPositions[i] + (randomTargets[i] - originalPositions[i]) * factor;
                    const ty = originalPositions[i+1] + (randomTargets[i+1] - originalPositions[i+1]) * factor;
                    const tz = originalPositions[i+2] + (randomTargets[i+2] - originalPositions[i+2]) * factor;
                    
                    pos[i] += (tx - pos[i]) * 0.1;
                    pos[i+1] += (ty - pos[i+1]) * 0.1;
                    pos[i+2] += (tz - pos[i+2]) * 0.1;
                }
                particles.geometry.attributes.position.needsUpdate = true;
                particles.rotation.y = Math.sin(Date.now() * 0.0005) * 0.15; // ç¨å¾®åŠ å¤§ä¸€ç‚¹è‡ªè½¬è§’åº¦
            }
            renderer.render(scene, camera);
        }

        // æ‰‹åŠ¿éƒ¨åˆ†
        try {
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            hands.setOptions({maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.5});
            hands.onResults((results) => {
                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    const lm = results.multiHandLandmarks[0];
                    const dist = Math.sqrt(Math.pow(lm[4].x - lm[8].x, 2) + Math.pow(lm[4].y - lm[8].y, 2));
                    handOpenness = Math.max(0, Math.min(1, (dist - 0.04) * 3));
                } else {
                    handOpenness = 0;
                }
            });
            
            const video = document.getElementsByClassName('input_video')[0];
            const cameraUtils = new Camera(video, {
                onFrame: async () => { await hands.send({image: video}); },
                width: 640, height: 480
            });
            cameraUtils.start();
        } catch(e) {}
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
