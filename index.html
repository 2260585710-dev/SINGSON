<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>AR ‰∫îÂ±ÇÁ∫πÊ†∑ (ÁªàÊûÅÁâà)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; }
        #input-video { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; z-index: 0; transform: scaleX(-1); }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; pointer-events: none; }
        #status-box {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            text-align: center; color: white; z-index: 20; pointer-events: none;
            background: rgba(0,0,0,0.8); padding: 20px; border-radius: 12px;
            width: 80%; max-width: 300px; font-size: 16px; line-height: 1.5;
        }
        #interaction-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 100; background: transparent; display: flex;
            justify-content: center; align-items: flex-end; padding-bottom: 50px;
        }
        #hint-text {
            color: rgba(255,255,255,0.7); font-size: 14px; 
            background: rgba(0,0,0,0.3); padding: 8px 15px; border-radius: 20px;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="status-box">1. ÂàùÂßãÂåñ...</div>
    <video id="input-video" playsinline></video>
    <div id="canvas-container"></div>
    <div id="interaction-layer"><div id="hint-text">üëÜ ÁÇπÂáªÂ±èÂπïÂºÄÂêØ‰ΩìÈ™å</div></div>
    <audio id="bgm" loop><source src="bgm.mp3" type="audio/mpeg"></audio>

    <script src="https://cdn.staticfile.org/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script>
        // === ÈÖçÁΩÆÂå∫ÂüüÔºö‰Ω†ÊÉ≥Âä†Âá†Â±ÇÂ∞±Âú®ËøôÈáåÂÜôÂá†Ë°å ===
        const LAYERS_CONFIG = [
            { file: 'pattern_inner.png',  speed: 0.005, density: 90,  dispScale: 1.0 }, // Á¨¨1Â±Ç (ÊúÄÂø´)
            { file: 'pattern_outer.png',  speed: 0.004, density: 100, dispScale: 1.2 }, // Á¨¨2Â±Ç
            { file: 'pattern_outer2.png', speed: 0.003, density: 100, dispScale: 1.4 }, // Á¨¨3Â±Ç
            { file: 'pattern_outer3.png', speed: 0.002, density: 110, dispScale: 1.6 }, // Á¨¨4Â±Ç
            { file: 'pattern_outer4.png', speed: 0.001, density: 110, dispScale: 1.8 }  // Á¨¨5Â±Ç (ÊúÄÊÖ¢)
        ];
        
        // Áªü‰∏ÄÁâ©ÁêÜÂ∞∫ÂØ∏ (Âõ†‰∏∫‰Ω†ÁöÑÂõæÈÉΩÊòØ 2000x2000 ÊãºÂ•ΩÁöÑ)
        const BASE_SIZE = 3.0; 

        window.onerror = function(msg) {
            document.getElementById('status-box').innerText = "‚ùå ÈîôËØØ: " + msg;
            return false;
        };

        const statusBox = document.getElementById('status-box');
        const interactionLayer = document.getElementById('interaction-layer');
        const bgm = document.getElementById('bgm');

        interactionLayer.addEventListener('click', () => {
            bgm.play().then(() => { interactionLayer.style.display = 'none'; })
               .catch(e => { interactionLayer.style.display = 'none'; });
        });

        let scene, camera, renderer;
        let systems = []; // Â≠òÂÇ®ÊâÄÊúâÂ±ÇÁ∫ßÁöÑÊï∞ÁªÑ
        let targetFactor = 0; 
        let currentFactor = 0;

        window.onload = function() { init(); };

        function init() {
            statusBox.innerText = "2. ÂêØÂä® 3D ÂºïÊìé...";
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 3.8; // ‰∫îÂ±ÇÊØîËæÉÂéöÔºåÁõ∏Êú∫ÊãâËøú‰∏ÄÁÇπÁÇπ

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio > 2 ? 2 : window.devicePixelRatio);
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            
            statusBox.innerText = "3. Âä†ËΩΩ 5 Â±ÇÁ∫πÊ†∑...";
            const loader = new THREE.TextureLoader();
            
            // Âä®ÊÄÅÁîüÊàêÂä†ËΩΩ‰ªªÂä°
            const loadPromises = LAYERS_CONFIG.map(config => loadTexturePromise(loader, config.file));

            Promise.all(loadPromises).then(textures => {
                textures.forEach((tex, index) => {
                    const config = LAYERS_CONFIG[index];
                    // ÂàõÂª∫ÊØè‰∏ÄÂ±Ç
                    const sys = createLayer(tex, BASE_SIZE, config.density, config.dispScale);
                    // ÁªëÂÆöÈÄüÂ∫¶ÈÖçÁΩÆ
                    sys.rotationSpeed = config.speed;
                    // Âä†ÂÖ•Êï∞ÁªÑÁÆ°ÁêÜ
                    systems.push(sys);
                    scene.add(sys.group);
                });
                
                statusBox.innerText = "4. ÂêØÂä® AI...";
                startCamera();
            }).catch(err => { 
                statusBox.innerHTML = "‚ùå Âä†ËΩΩÂ§±Ë¥•<br>ËØ∑Ê£ÄÊü•5Âº†ÂõæÁâáÊñá‰ª∂ÂêçÊòØÂê¶Ê≠£Á°Æ"; 
            });

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function loadTexturePromise(loader, url) {
            return new Promise((resolve, reject) => { loader.load(url, resolve, undefined, reject); });
        }

        function createLayer(texture, size, density, disperseScale) {
            const systemObj = { group: new THREE.Group(), mesh: null, particles: null, origPos: null, dispPos: null };

            // ÂÆû‰ΩìÂ±Ç
            const planeGeo = new THREE.PlaneGeometry(size, size);
            const planeMat = new THREE.MeshBasicMaterial({ 
                map: texture, transparent: true, opacity: 0, depthWrite: false, side: THREE.DoubleSide 
            });
            systemObj.mesh = new THREE.Mesh(planeGeo, planeMat);
            systemObj.group.add(systemObj.mesh);

            // Á≤íÂ≠êÂ±Ç
            const img = texture.image;
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = density; canvas.height = density;
            ctx.drawImage(img, 0, 0, density, density);
            const data = ctx.getImageData(0, 0, density, density).data;

            const validPositions = []; const validColors = [];
            for(let i = 0; i < density * density; i++) {
                const r = data[i*4], g = data[i*4+1], b = data[i*4+2], a = data[i*4+3];
                if (a > 50) { 
                    const x = i % density, y = Math.floor(i / density);
                    const u = (x / density - 0.5) * size;
                    const v = (y / density - 0.5) * size;
                    validPositions.push(u, -v, 0);
                    validColors.push(r/255*1.2, g/255*1.2, b/255*1.2);
                }
            }

            const count = validPositions.length / 3;
            const geometry = new THREE.BufferGeometry();
            systemObj.origPos = new Float32Array(validPositions);
            systemObj.dispPos = new Float32Array(count * 3);
            const colors = new Float32Array(validColors);

            for(let i = 0; i < count * 3; i+=3) {
                const r = (0.5 + Math.random() * 2.5) * disperseScale; 
                const angle = Math.random() * Math.PI * 2; 
                const h = (Math.random() - 0.5) * 4 * disperseScale; 
                const twist = h * 2.0; 
                systemObj.dispPos[i] = r * Math.cos(angle + twist);     
                systemObj.dispPos[i+1] = h + 1.0;                       
                systemObj.dispPos[i+2] = r * Math.sin(angle + twist);   
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(systemObj.dispPos.slice(), 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            systemObj.particles = new THREE.Points(geometry, new THREE.PointsMaterial({
                size: 0.018, vertexColors: true, transparent: true, opacity: 0.95, blending: THREE.AdditiveBlending, depthWrite: false
            }));
            systemObj.group.add(systemObj.particles);
            
            // ZËΩ¥ÂæÆË∞ÉÈò≤Ê≠¢Èó™ÁÉÅ
            systemObj.group.position.z = Math.random() * 0.01; 
            
            return systemObj;
        }

        function startCamera() {
            const videoElement = document.getElementById('input-video');
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            hands.setOptions({ maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
            
            hands.onResults(results => {
                if (statusBox.style.display !== 'none') statusBox.style.display = 'none';
                let newTarget = 0; 
                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    const lm = results.multiHandLandmarks[0];
                    const dist = Math.sqrt(Math.pow(lm[4].x - lm[8].x, 2) + Math.pow(lm[4].y - lm[8].y, 2));
                    if (dist < 0.05) newTarget = 1; 
                } 
                targetFactor = newTarget;
            });

            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => { await hands.send({image: videoElement}); },
                width: 640, height: 480
            });
            cameraUtils.start().catch(err => statusBox.innerText = "‚ùå ÊëÑÂÉèÂ§¥Â§±Ë¥•: " + err);
            
            animate();
        }

        function updateSystem(system, time) {
            if (!system.particles) return;

            // ËØªÂèñÁªëÂÆöÁöÑÈÄüÂ∫¶ËøõË°åÊóãËΩ¨
            system.group.rotation.z -= system.rotationSpeed;

            if (currentFactor > 0.8) {
                let alpha = (currentFactor - 0.8) * 5;
                if(alpha > 1) alpha = 1;
                system.mesh.material.opacity = alpha;
                system.particles.material.opacity = 0.95 * (1 - alpha);
            } else {
                system.mesh.material.opacity = 0;
                system.particles.material.opacity = 0.95;
            }

            system.particles.material.size = 0.028 - (currentFactor * 0.012);
            const positions = system.particles.geometry.attributes.position.array;
            const orig = system.origPos;
            const disp = system.dispPos;

            for(let i = 0; i < positions.length; i+=3) {
                const ox = orig[i], oy = orig[i+1]; 
                let dx = disp[i], dy = disp[i+1], dz = disp[i+2];
                
                if (currentFactor < 0.8) {
                    const rotAngle = time * 0.5; 
                    const oldDx = dx;
                    dx = oldDx * Math.cos(rotAngle) - dz * Math.sin(rotAngle);
                    dz = oldDx * Math.sin(rotAngle) + dz * Math.cos(rotAngle);
                }

                positions[i] = dx + (ox - dx) * currentFactor;
                positions[i+1] = dy + (oy - dy) * currentFactor;
                positions[i+2] = dz + (orig[i+2] - dz) * currentFactor; 
            }
            system.particles.geometry.attributes.position.needsUpdate = true;
        }

        function animate() {
            requestAnimationFrame(animate);
            currentFactor += (targetFactor - currentFactor) * 0.1;
            const time = Date.now() * 0.001;

            // Âæ™ÁéØÊõ¥Êñ∞ÊâÄÊúâÂ±Ç
            systems.forEach(sys => updateSystem(sys, time));

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
