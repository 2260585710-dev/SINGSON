<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>AR äº”å±‚çº¹æ · (å¯è°ƒå‚ç‰ˆ)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; }
        #input-video { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; z-index: 0; transform: scaleX(-1); }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; pointer-events: none; }
        
        /* çŠ¶æ€æç¤º */
        #status-box {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            text-align: center; color: white; z-index: 20; pointer-events: none;
            background: rgba(0,0,0,0.8); padding: 20px; border-radius: 12px;
            width: 80%; max-width: 300px;
        }

        /* åº•éƒ¨æ“ä½œå±‚ */
        #interaction-layer {
            position: absolute; bottom: 30px; width: 100%; text-align: center; z-index: 100;
        }
        #hint-text {
            color: rgba(255,255,255,0.8); font-size: 14px; 
            background: rgba(0,0,0,0.5); padding: 8px 15px; border-radius: 20px;
            display: inline-block; cursor: pointer;
        }

        /* === æ–°å¢ï¼šå·¦ä¸Šè§’æ§åˆ¶é¢æ¿ === */
        #control-panel {
            position: absolute; top: 10px; left: 10px; z-index: 50;
            background: rgba(0, 0, 0, 0.6); padding: 10px; border-radius: 8px;
            color: white; font-size: 12px; width: 140px;
            backdrop-filter: blur(4px);
        }
        .control-item { margin-bottom: 8px; }
        .control-item label { display: block; margin-bottom: 2px; }
        .control-item input { width: 100%; }
        /* éšè—æŒ‰é’® */
        #toggle-controls {
            position: absolute; top: 10px; right: 10px; z-index: 51;
            background: rgba(255,255,255,0.2); border: none; color: white;
            padding: 5px 10px; border-radius: 4px; cursor: pointer;
        }
    </style>
</head>
<body>
    <div id="status-box">1. åˆå§‹åŒ–...</div>
    <video id="input-video" playsinline></video>
    <div id="canvas-container"></div>
    
    <div id="interaction-layer">
        <div id="hint-text">ğŸµ ç‚¹å‡»æ’­æ”¾éŸ³ä¹</div>
    </div>
    
    <!-- æ§åˆ¶é¢æ¿å¼€å…³ -->
    <button id="toggle-controls">ğŸ› ï¸ è°ƒæ•´</button>

    <!-- æ§åˆ¶é¢æ¿ -->
    <div id="control-panel">
        <div class="control-item">
            <label>ç¬¬1å±‚å¤§å° (å†…): <span id="val1">1.5</span></label>
            <input type="range" id="slider1" min="0.5" max="5.0" step="0.1" value="1.5">
        </div>
        <div class="control-item">
            <label>ç¬¬2å±‚å¤§å°: <span id="val2">2.2</span></label>
            <input type="range" id="slider2" min="0.5" max="5.0" step="0.1" value="2.2">
        </div>
        <div class="control-item">
            <label>ç¬¬3å±‚å¤§å°: <span id="val3">2.9</span></label>
            <input type="range" id="slider3" min="0.5" max="5.0" step="0.1" value="2.9">
        </div>
        <div class="control-item">
            <label>ç¬¬4å±‚å¤§å°: <span id="val4">3.6</span></label>
            <input type="range" id="slider4" min="0.5" max="5.0" step="0.1" value="3.6">
        </div>
        <div class="control-item">
            <label>ç¬¬5å±‚å¤§å° (å¤–): <span id="val5">4.3</span></label>
            <input type="range" id="slider5" min="0.5" max="6.0" step="0.1" value="4.3">
        </div>
    </div>

    <audio id="bgm" loop><source src="bgm.mp3" type="audio/mpeg"></audio>

    <script src="https://cdn.staticfile.org/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script>
        // åˆå§‹é…ç½®
        const LAYERS_CONFIG = [
            { file: 'pattern_inner.png',  size: 1.5, speed: 0.005, density: 90,  dispScale: 1.0 },
            { file: 'pattern_outer.png',  size: 2.2, speed: 0.004, density: 100, dispScale: 1.2 },
            { file: 'pattern_outer2.png', size: 2.9, speed: 0.003, density: 100, dispScale: 1.4 },
            { file: 'pattern_outer3.png', size: 3.6, speed: 0.002, density: 110, dispScale: 1.6 },
            { file: 'pattern_outer4.png', size: 4.3, speed: 0.001, density: 110, dispScale: 1.8 }
        ];

        window.onerror = function(msg) {
            document.getElementById('status-box').innerText = "âŒ é”™è¯¯: " + msg;
            return false;
        };

        const statusBox = document.getElementById('status-box');
        const hintText = document.getElementById('hint-text');
        const bgm = document.getElementById('bgm');
        const controlPanel = document.getElementById('control-panel');
        const toggleBtn = document.getElementById('toggle-controls');

        // éŸ³ä¹æ’­æ”¾
        hintText.addEventListener('click', () => {
            bgm.play().then(() => { hintText.style.display = 'none'; })
               .catch(e => { hintText.innerText = "æ— éŸ³ä¹æ–‡ä»¶"; });
        });

        // åˆ‡æ¢æ§åˆ¶é¢æ¿æ˜¾ç¤º/éšè—
        toggleBtn.addEventListener('click', () => {
            if (controlPanel.style.display === 'none') {
                controlPanel.style.display = 'block';
            } else {
                controlPanel.style.display = 'none';
            }
        });

        let scene, camera, renderer;
        let systems = []; 
        let targetFactor = 0; 
        let currentFactor = 0;

        window.onload = function() { init(); };

        function init() {
            statusBox.innerText = "2. å¯åŠ¨ 3D å¼•æ“...";
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 4.5; 

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio > 2 ? 2 : window.devicePixelRatio);
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            
            statusBox.innerText = "3. åŠ è½½ 5 å±‚çº¹æ ·...";
            const loader = new THREE.TextureLoader();
            
            const loadPromises = LAYERS_CONFIG.map(config => loadTexturePromise(loader, config.file));

            Promise.all(loadPromises).then(textures => {
                textures.forEach((tex, index) => {
                    const config = LAYERS_CONFIG[index];
                    const sys = createLayer(tex, config.size, config.density, config.dispScale);
                    sys.rotationSpeed = config.speed;
                    sys.baseSize = config.size; // è®°å½•åˆå§‹å¤§å°
                    systems.push(sys);
                    scene.add(sys.group);

                    // === ç»‘å®šæ»‘å—äº‹ä»¶ ===
                    const slider = document.getElementById(`slider${index+1}`);
                    const labelSpan = document.getElementById(`val${index+1}`);
                    
                    slider.addEventListener('input', (e) => {
                        const newSize = parseFloat(e.target.value);
                        labelSpan.innerText = newSize.toFixed(1);
                        
                        // å®æ—¶æ›´æ–°è¿™ä¸€å±‚çš„å¤§å°
                        // å› ä¸ºæˆ‘ä»¬ä¸èƒ½ç›´æ¥æ”¹ geometry çš„å¤§å°ï¼Œæ‰€ä»¥ç”¨ scale ç¼©æ”¾ group
                        // åˆå§‹ geometry æ˜¯æŒ‰ baseSize å»ºçš„ï¼Œç°åœ¨ scale = newSize / baseSize
                        const scale = newSize / sys.baseSize;
                        sys.group.scale.set(scale, scale, 1);
                        
                        // æ›´æ–°Zè½´æ’åºï¼Œé¿å…é®æŒ¡
                        sys.group.position.z = (6.0 - newSize) * 0.05;
                    });
                });
                
                statusBox.innerText = "4. å¯åŠ¨ AI...";
                startCamera();
            }).catch(err => { 
                statusBox.innerHTML = "âŒ åŠ è½½å¤±è´¥<br>è¯·æ£€æŸ¥5å¼ å›¾ç‰‡æ–‡ä»¶å"; 
            });

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function loadTexturePromise(loader, url) {
            return new Promise((resolve, reject) => { loader.load(url, resolve, undefined, reject); });
        }

        function createLayer(texture, size, density, disperseScale) {
            const systemObj = { group: new THREE.Group(), mesh: null, particles: null, origPos: null, dispPos: null };

            // å®ä½“å±‚
            const planeGeo = new THREE.PlaneGeometry(size, size);
            const planeMat = new THREE.MeshBasicMaterial({ 
                map: texture, transparent: true, opacity: 0, depthWrite: false, side: THREE.DoubleSide 
            });
            systemObj.mesh = new THREE.Mesh(planeGeo, planeMat);
            systemObj.group.add(systemObj.mesh);

            // ç²’å­å±‚
            const img = texture.image;
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = density; canvas.height = density;
            ctx.drawImage(img, 0, 0, density, density);
            const data = ctx.getImageData(0, 0, density, density).data;

            const validPositions = []; const validColors = [];
            for(let i = 0; i < density * density; i++) {
                const r = data[i*4], g = data[i*4+1], b = data[i*4+2], a = data[i*4+3];
                if (a > 50) { 
                    const x = i % density, y = Math.floor(i / density);
                    const u = (x / density - 0.5) * size;
                    const v = (y / density - 0.5) * size;
                    validPositions.push(u, -v, 0);
                    validColors.push(r/255*1.2, g/255*1.2, b/255*1.2);
                }
            }

            const count = validPositions.length / 3;
            const geometry = new THREE.BufferGeometry();
            systemObj.origPos = new Float32Array(validPositions);
            systemObj.dispPos = new Float32Array(count * 3);
            const colors = new Float32Array(validColors);

            for(let i = 0; i < count * 3; i+=3) {
                const r = (0.5 + Math.random() * 2.5) * disperseScale; 
                const angle = Math.random() * Math.PI * 2; 
                const h = (Math.random() - 0.5) * 4 * disperseScale; 
                const twist = h * 2.0; 
                systemObj.dispPos[i] = r * Math.cos(angle + twist);     
                systemObj.dispPos[i+1] = h + 1.0;                       
                systemObj.dispPos[i+2] = r * Math.sin(angle + twist);   
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(systemObj.dispPos.slice(), 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            systemObj.particles = new THREE.Points(geometry, new THREE.PointsMaterial({
                size: 0.018, vertexColors: true, transparent: true, opacity: 0.95, blending: THREE.AdditiveBlending, depthWrite: false
            }));
            systemObj.group.add(systemObj.particles);
            
            // åˆå§‹Zè½´æ’åº
            systemObj.group.position.z = (6.0 - size) * 0.05; 
            
            return systemObj;
        }

        function startCamera() {
            const videoElement = document.getElementById('input-video');
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            hands.setOptions({ maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
            
            hands.onResults(results => {
                if (statusBox.style.display !== 'none') statusBox.style.display = 'none';
                let newTarget = 0; 
                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    const lm = results.multiHandLandmarks[0];
                    const dist = Math.sqrt(Math.pow(lm[4].x - lm[8].x, 2) + Math.pow(lm[4].y - lm[8].y, 2));
                    if (dist < 0.05) newTarget = 1; 
                } 
                targetFactor = newTarget;
            });

            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => { await hands.send({image: videoElement}); },
                width: 640, height: 480
            });
            cameraUtils.start().catch(err => statusBox.innerText = "âŒ æ‘„åƒå¤´å¤±è´¥: " + err);
            
            animate();
        }

        function updateSystem(system, time) {
            if (!system.particles) return;

            system.group.rotation.z -= system.rotationSpeed;

            if (currentFactor > 0.8) {
                let alpha = (currentFactor - 0.8) * 5;
                if(alpha > 1) alpha = 1;
                system.mesh.material.opacity = alpha;
                system.particles.material.opacity = 0.95 * (1 - alpha);
            } else {
                system.mesh.material.opacity = 0;
                system.particles.material.opacity = 0.95;
            }

            system.particles.material.size = 0.028 - (currentFactor * 0.012);
            const positions = system.particles.geometry.attributes.position.array;
            const orig = system.origPos;
            const disp = system.dispPos;

            for(let i = 0; i < positions.length; i+=3) {
                const ox = orig[i], oy = orig[i+1]; 
                let dx = disp[i], dy = disp[i+1], dz = disp[i+2];
                
                if (currentFactor < 0.8) {
                    const rotAngle = time * 0.5; 
                    const oldDx = dx;
                    dx = oldDx * Math.cos(rotAngle) - dz * Math.sin(rotAngle);
                    dz = oldDx * Math.sin(rotAngle) + dz * Math.cos(rotAngle);
                }

                positions[i] = dx + (ox - dx) * currentFactor;
                positions[i+1] = dy + (oy - dy) * currentFactor;
                positions[i+2] = dz + (orig[i+2] - dz) * currentFactor; 
            }
            system.particles.geometry.attributes.position.needsUpdate = true;
        }

        function animate() {
            requestAnimationFrame(animate);
            currentFactor += (targetFactor - currentFactor) * 0.1;
            const time = Date.now() * 0.001;

            systems.forEach(sys => updateSystem(sys, time));

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
