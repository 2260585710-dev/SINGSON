<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>AR ÁªàÊûÅÊûÅÈÄüÁâà</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; }
        
        /* Âè≥‰∏ãËßíÊëÑÂÉèÂ§¥Â∞èÁ™ó */
        #input-video {
            position: absolute; bottom: 20px; right: 20px; 
            width: 120px; height: 160px; 
            object-fit: cover; z-index: 100; 
            transform: scaleX(-1);
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            opacity: 0.8;
        }

        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        
        #status-box {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            text-align: center; color: white; z-index: 20; pointer-events: none;
            background: rgba(0,0,0,0.8); padding: 20px; border-radius: 12px;
            width: 80%; max-width: 300px; font-size: 16px;
        }

        #interaction-layer {
            position: absolute; bottom: 30px; left: 20px; z-index: 100;
        }
        #hint-text {
            color: rgba(255,255,255,0.8); font-size: 14px; 
            background: rgba(0,0,0,0.5); padding: 10px 20px; border-radius: 20px;
            cursor: pointer; border: 1px solid rgba(255,255,255,0.3);
        }
    </style>
</head>
<body>
    <div id="status-box">1. ÂàùÂßãÂåñ...</div>
    <video id="input-video" playsinline></video>
    <div id="canvas-container"></div>
    <div id="interaction-layer"><div id="hint-text">üéµ ÁÇπÂáªÊí≠ÊîæÈü≥‰πê</div></div>
    <audio id="bgm" loop><source src="bgm.mp3" type="audio/mpeg"></audio>

    <!-- ÊûÅÈÄüÊ∫ê -->
    <script src="https://cdn.staticfile.org/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script>
        // === È¢ÑËÆæÂ•ΩÁöÑÊúÄ‰Ω≥ÂèÇÊï∞ ===
        const LAYERS_CONFIG = [
            { file: 'pattern_inner.png',  size: 1.5, speed: 0.005, density: 90,  dispScale: 1.0 },
            { file: 'pattern_outer.png',  size: 2.2, speed: 0.004, density: 100, dispScale: 1.2 },
            { file: 'pattern_outer2.png', size: 2.9, speed: 0.003, density: 100, dispScale: 1.4 },
            { file: 'pattern_outer3.png', size: 3.6, speed: 0.002, density: 110, dispScale: 1.6 },
            { file: 'pattern_outer4.png', size: 4.3, speed: 0.001, density: 110, dispScale: 1.8 }
        ];

        window.onerror = function(msg) {
            document.getElementById('status-box').innerText = "‚ùå ÈîôËØØ: " + msg;
            return false;
        };

        const statusBox = document.getElementById('status-box');
        const hintText = document.getElementById('hint-text');
        const bgm = document.getElementById('bgm');

        hintText.addEventListener('click', () => {
            bgm.play().then(() => { hintText.style.display = 'none'; })
               .catch(e => { hintText.innerText = "Êó†Èü≥‰πêÊñá‰ª∂"; });
        });

        let scene, camera, renderer;
        let systems = []; 
        let targetFactor = 0; 
        let currentFactor = 0;

        window.onload = function() { init(); };

        function init() {
            statusBox.innerText = "2. ÂêØÂä® 3D ÂºïÊìé...";
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000); // Á∫ØÈªëËÉåÊôØ

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 4.5; 

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            // ÈôêÂà∂ÂÉèÁ¥†ÊØîÔºå‰øùËØÅÊµÅÁïÖÂ∫¶
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            
            statusBox.innerText = "3. Âä†ËΩΩ 5 Â±ÇÁ∫πÊ†∑...";
            const loader = new THREE.TextureLoader();
            
            const loadPromises = LAYERS_CONFIG.map(config => loadTexturePromise(loader, config.file));

            Promise.all(loadPromises).then(textures => {
                textures.forEach((tex, index) => {
                    const config = LAYERS_CONFIG[index];
                    const sys = createLayer(tex, config.size, config.density, config.dispScale);
                    sys.rotationSpeed = config.speed;
                    systems.push(sys);
                    scene.add(sys.group);
                });
                
                statusBox.innerText = "4. ÂêØÂä® AI...";
                startCamera();
            }).catch(err => { 
                statusBox.innerHTML = "‚ùå Âä†ËΩΩÂ§±Ë¥•<br>ËØ∑Ê£ÄÊü•5Âº†ÂõæÁâáÊñá‰ª∂Âêç"; 
            });

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function loadTexturePromise(loader, url) {
            return new Promise((resolve, reject) => { loader.load(url, resolve, undefined, reject); });
        }

        function createLayer(texture, size, density, disperseScale) {
            const systemObj = { group: new THREE.Group(), mesh: null, glow: null, particles: null, origPos: null, dispPos: null };

            // 1. ÂèëÂÖâÂ±Ç
            const glowGeo = new THREE.PlaneGeometry(size * 1.1, size * 1.1);
            const glowMat = new THREE.MeshBasicMaterial({ 
                map: texture, transparent: true, opacity: 0, 
                color: 0xffaa00, blending: THREE.AdditiveBlending, depthWrite: false, side: THREE.DoubleSide
            });
            systemObj.glow = new THREE.Mesh(glowGeo, glowMat);
            systemObj.glow.position.z = -0.05;
            systemObj.group.add(systemObj.glow);

            // 2. ÂÆû‰ΩìÂ±Ç
            const planeGeo = new THREE.PlaneGeometry(size, size);
            const planeMat = new THREE.MeshBasicMaterial({ 
                map: texture, transparent: true, opacity: 0, depthWrite: false, side: THREE.DoubleSide 
            });
            systemObj.mesh = new THREE.Mesh(planeGeo, planeMat);
            systemObj.group.add(systemObj.mesh);

            // 3. Á≤íÂ≠êÂ±Ç
            const img = texture.image;
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = density; canvas.height = density;
            ctx.drawImage(img, 0, 0, density, density);
            const data = ctx.getImageData(0, 0, density, density).data;

            const validPositions = []; const validColors = [];
            for(let i = 0; i < density * density; i++) {
                const r = data[i*4], g = data[i*4+1], b = data[i*4+2], a = data[i*4+3];
                if (a > 50) { 
                    const x = i % density, y = Math.floor(i / density);
                    const u = (x / density - 0.5) * size;
                    const v = (y / density - 0.5) * size;
                    validPositions.push(u, -v, 0);
                    validColors.push(r/255*1.2, g/255*1.2, b/255*1.2);
                }
            }

            const count = validPositions.length / 3;
            const geometry = new THREE.BufferGeometry();
            systemObj.origPos = new Float32Array(validPositions);
            systemObj.dispPos = new Float32Array(count * 3);
            const colors = new Float32Array(validColors);

            for(let i = 0; i < count * 3; i+=3) {
                const r = (0.5 + Math.random() * 2.5) * disperseScale; 
                const angle = Math.random() * Math.PI * 2; 
                const h = (Math.random() - 0.5) * 4 * disperseScale; 
                const twist = h * 2.0; 
                systemObj.dispPos[i] = r * Math.cos(angle + twist);     
                systemObj.dispPos[i+1] = h + 1.0;                       
                systemObj.dispPos[i+2] = r * Math.sin(angle + twist);   
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(systemObj.dispPos.slice(), 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            systemObj.particles = new THREE.Points(geometry, new THREE.PointsMaterial({
                size: 0.018, vertexColors: true, transparent: true, opacity: 0.95, blending: THREE.AdditiveBlending, depthWrite: false
            }));
            systemObj.group.add(systemObj.particles);
            
            systemObj.group.position.z = (6.0 - size) * 0.05; 
            
            return systemObj;
        }

        function startCamera() {
            const videoElement = document.getElementById('input-video');
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            
            // ‰ΩøÁî®ÊúÄËΩªÈáèÊ®°Âûã modelComplexity: 0
            hands.setOptions({ maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
            
            hands.onResults(results => {
                if (statusBox.style.display !== 'none') statusBox.style.display = 'none';
                let newTarget = 0; 
                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    const lm = results.multiHandLandmarks[0];
                    const dist = Math.sqrt(Math.pow(lm[4].x - lm[8].x, 2) + Math.pow(lm[4].y - lm[8].y, 2));
                    if (dist < 0.05) newTarget = 1; 
                } 
                targetFactor = newTarget;
            });

            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => { await hands.send({image: videoElement}); },
                width: 640, height: 480
            });
            cameraUtils.start().catch(err => statusBox.innerText = "‚ùå ÊëÑÂÉèÂ§¥Â§±Ë¥•: " + err);
            
            animate();
        }

        function updateSystem(system, time) {
            if (!system.particles) return;

            system.group.rotation.z -= system.rotationSpeed;

            if (currentFactor > 0.8) {
                let alpha = (currentFactor - 0.8) * 5;
                if(alpha > 1) alpha = 1;
                
                system.mesh.material.opacity = alpha;
                system.particles.material.opacity = 0.95 * (1 - alpha);
                
                // ÂèëÂÖâÂ±ÇÂëºÂê∏
                const glowStrength = (Math.sin(time) * 0.2 + 0.8) * alpha * 0.6;
                system.glow.material.opacity = glowStrength;
            } else {
                system.mesh.material.opacity = 0;
                system.glow.material.opacity = 0;
                system.particles.material.opacity = 0.95;
            }

            system.particles.material.size = 0.028 - (currentFactor * 0.012);
            const positions = system.particles.geometry.attributes.position.array;
            const orig = system.origPos;
            const disp = system.dispPos;

            for(let i = 0; i < positions.length; i+=3) {
                const ox = orig[i], oy = orig[i+1]; 
                let dx = disp[i], dy = disp[i+1], dz = disp[i+2];
                
                if (currentFactor < 0.8) {
                    const rotAngle = time * 0.5; 
                    const oldDx = dx;
                    dx = oldDx * Math.cos(rotAngle) - dz * Math.sin(rotAngle);
                    dz = oldDx * Math.sin(rotAngle) + dz * Math.cos(rotAngle);
                }

                positions[i] = dx + (ox - dx) * currentFactor;
                positions[i+1] = dy + (oy - dy) * currentFactor;
                positions[i+2] = dz + (orig[i+2] - dz) * currentFactor; 
            }
            system.particles.geometry.attributes.position.needsUpdate = true;
        }

        function animate() {
            requestAnimationFrame(animate);
            currentFactor += (targetFactor - currentFactor) * 0.1;
            const time = Date.now() * 0.001;

            systems.forEach(sys => updateSystem(sys, time));

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
