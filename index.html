<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>AR äº”å±‚å®Œç¾åµŒå¥—ç‰ˆ</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; }
        #input-video { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; z-index: 0; transform: scaleX(-1); }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; pointer-events: none; }
        #status-box {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            text-align: center; color: white; z-index: 20; pointer-events: none;
            background: rgba(0,0,0,0.8); padding: 20px; border-radius: 12px;
            width: 80%; max-width: 300px; font-size: 16px; line-height: 1.5;
        }
        #interaction-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 100; background: transparent; display: flex;
            justify-content: center; align-items: flex-end; padding-bottom: 50px;
        }
        #hint-text {
            color: rgba(255,255,255,0.7); font-size: 14px; 
            background: rgba(0,0,0,0.3); padding: 8px 15px; border-radius: 20px;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="status-box">1. åˆå§‹åŒ–...</div>
    <video id="input-video" playsinline></video>
    <div id="canvas-container"></div>
    <div id="interaction-layer"><div id="hint-text">ğŸ‘† ç‚¹å‡»å±å¹•å¼€å¯ä½“éªŒ</div></div>
    <audio id="bgm" loop><source src="bgm.mp3" type="audio/mpeg"></audio>

    <script src="https://cdn.staticfile.org/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script>
        // === å…³é”®ä¿®æ”¹ï¼šæ‰‹åŠ¨æŒ‡å®šæ¯ä¸€å±‚çš„ç‰©ç†æ˜¾ç¤ºå¤§å° ===
        const LAYERS_CONFIG = [
            { file: 'pattern_inner.png',  size: 1.5, speed: 0.005, density: 90,  dispScale: 1.0 }, // ç¬¬1å±‚ï¼šæœ€å°
            { file: 'pattern_outer.png',  size: 2.2, speed: 0.004, density: 100, dispScale: 1.2 }, // ç¬¬2å±‚ï¼šå¤§ä¸€åœˆ
            { file: 'pattern_outer2.png', size: 2.9, speed: 0.003, density: 100, dispScale: 1.4 }, // ç¬¬3å±‚ï¼šå†å¤§ä¸€åœˆ
            { file: 'pattern_outer3.png', size: 3.6, speed: 0.002, density: 110, dispScale: 1.6 }, // ç¬¬4å±‚
            { file: 'pattern_outer4.png', size: 4.3, speed: 0.001, density: 110, dispScale: 1.8 }  // ç¬¬5å±‚ï¼šæœ€å¤§
        ];

        window.onerror = function(msg) {
            document.getElementById('status-box').innerText = "âŒ é”™è¯¯: " + msg;
            return false;
        };

        const statusBox = document.getElementById('status-box');
        const interactionLayer = document.getElementById('interaction-layer');
        const bgm = document.getElementById('bgm');

        interactionLayer.addEventListener('click', () => {
            bgm.play().then(() => { interactionLayer.style.display = 'none'; })
               .catch(e => { interactionLayer.style.display = 'none'; });
        });

        let scene, camera, renderer;
        let systems = []; 
        let targetFactor = 0; 
        let currentFactor = 0;

        window.onload = function() { init(); };

        function init() {
            statusBox.innerText = "2. å¯åŠ¨ 3D å¼•æ“...";
            scene = new THREE.Scene();
            // ç›¸æœºå†æ‹‰è¿œä¸€ç‚¹ï¼Œå› ä¸ºç¬¬5å±‚(4.3)éå¸¸å¤§ï¼Œéœ€è¦æ›´å¹¿çš„è§†é‡
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 4.5; 

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio > 2 ? 2 : window.devicePixelRatio);
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            
            statusBox.innerText = "3. åŠ è½½ 5 å±‚çº¹æ ·...";
            const loader = new THREE.TextureLoader();
            
            const loadPromises = LAYERS_CONFIG.map(config => loadTexturePromise(loader, config.file));

            Promise.all(loadPromises).then(textures => {
                textures.forEach((tex, index) => {
                    const config = LAYERS_CONFIG[index];
                    // ä½¿ç”¨é…ç½®é‡Œçš„ size å‚æ•°
                    const sys = createLayer(tex, config.size, config.density, config.dispScale);
                    sys.rotationSpeed = config.speed;
                    systems.push(sys);
                    scene.add(sys.group);
                });
                
                statusBox.innerText = "4. å¯åŠ¨ AI...";
                startCamera();
            }).catch(err => { 
                statusBox.innerHTML = "âŒ åŠ è½½å¤±è´¥<br>è¯·æ£€æŸ¥5å¼ å›¾ç‰‡æ–‡ä»¶åæ˜¯å¦æ­£ç¡®"; 
            });

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function loadTexturePromise(loader, url) {
            return new Promise((resolve, reject) => { loader.load(url, resolve, undefined, reject); });
        }

        function createLayer(texture, size, density, disperseScale) {
            const systemObj = { group: new THREE.Group(), mesh: null, particles: null, origPos: null, dispPos: null };

            // å®ä½“å±‚
            const planeGeo = new THREE.PlaneGeometry(size, size);
            const planeMat = new THREE.MeshBasicMaterial({ 
                map: texture, transparent: true, opacity: 0, depthWrite: false, side: THREE.DoubleSide 
            });
            systemObj.mesh = new THREE.Mesh(planeGeo, planeMat);
            systemObj.group.add(systemObj.mesh);

            // ç²’å­å±‚
            const img = texture.image;
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = density; canvas.height = density;
            ctx.drawImage(img, 0, 0, density, density);
            const data = ctx.getImageData(0, 0, density, density).data;

            const validPositions = []; const validColors = [];
            for(let i = 0; i < density * density; i++) {
                const r = data[i*4], g = data[i*4+1], b = data[i*4+2], a = data[i*4+3];
                if (a > 50) { 
                    const x = i % density, y = Math.floor(i / density);
                    // è¿™é‡Œçš„ size å·²ç»æ˜¯æˆ‘ä»¬æ‰‹åŠ¨æŒ‡å®šçš„å¤§å°(1.5 ~ 4.3)äº†
                    const u = (x / density - 0.5) * size;
                    const v = (y / density - 0.5) * size;
                    validPositions.push(u, -v, 0);
                    validColors.push(r/255*1.2, g/255*1.2, b/255*1.2);
                }
            }

            const count = validPositions.length / 3;
            const geometry = new THREE.BufferGeometry();
            systemObj.origPos = new Float32Array(validPositions);
            systemObj.dispPos = new Float32Array(count * 3);
            const colors = new Float32Array(validColors);

            for(let i = 0; i < count * 3; i+=3) {
                const r = (0.5 + Math.random() * 2.5) * disperseScale; 
                const angle = Math.random() * Math.PI * 2; 
                const h = (Math.random() - 0.5) * 4 * disperseScale; 
                const twist = h * 2.0; 
                systemObj.dispPos[i] = r * Math.cos(angle + twist);     
                systemObj.dispPos[i+1] = h + 1.0;                       
                systemObj.dispPos[i+2] = r * Math.sin(angle + twist);   
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(systemObj.dispPos.slice(), 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            systemObj.particles = new THREE.Points(geometry, new THREE.PointsMaterial({
                size: 0.018, vertexColors: true, transparent: true, opacity: 0.95, blending: THREE.AdditiveBlending, depthWrite: false
            }));
            systemObj.group.add(systemObj.particles);
            
            // å±‚çº§æ’åºï¼šæœ€å¤§çš„å±‚æ”¾åœ¨æœ€åº•ä¸‹(Z=0)ï¼Œæœ€å°çš„å±‚æ”¾æœ€ä¸Šé¢(Z>0)
            // 4.3 æ˜¯æœ€å¤§å°ºå¯¸ï¼Œsizeè¶Šå°ï¼ŒZå€¼è¶Šå¤§ï¼Œè¶Šé å‰
            systemObj.group.position.z = (4.3 - size) * 0.05; 
            
            return systemObj;
        }

        function startCamera() {
            const videoElement = document.getElementById('input-video');
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            hands.setOptions({ maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
            
            hands.onResults(results => {
                if (statusBox.style.display !== 'none') statusBox.style.display = 'none';
                let newTarget = 0; 
                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    const lm = results.multiHandLandmarks[0];
                    const dist = Math.sqrt(Math.pow(lm[4].x - lm[8].x, 2) + Math.pow(lm[4].y - lm[8].y, 2));
                    if (dist < 0.05) newTarget = 1; 
                } 
                targetFactor = newTarget;
            });

            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => { await hands.send({image: videoElement}); },
                width: 640, height: 480
            });
            cameraUtils.start().catch(err => statusBox.innerText = "âŒ æ‘„åƒå¤´å¤±è´¥: " + err);
            
            animate();
        }

        function updateSystem(system, time) {
            if (!system.particles) return;

            // åŒ€é€Ÿæ—‹è½¬
            system.group.rotation.z -= system.rotationSpeed;

            if (currentFactor > 0.8) {
                let alpha = (currentFactor - 0.8) * 5;
                if(alpha > 1) alpha = 1;
                system.mesh.material.opacity = alpha;
                system.particles.material.opacity = 0.95 * (1 - alpha);
            } else {
                system.mesh.material.opacity = 0;
                system.particles.material.opacity = 0.95;
            }

            system.particles.material.size = 0.028 - (currentFactor * 0.012);
            const positions = system.particles.geometry.attributes.position.array;
            const orig = system.origPos;
            const disp = system.dispPos;

            for(let i = 0; i < positions.length; i+=3) {
                const ox = orig[i], oy = orig[i+1]; 
                let dx = disp[i], dy = disp[i+1], dz = disp[i+2];
                
                if (currentFactor < 0.8) {
                    const rotAngle = time * 0.5; 
                    const oldDx = dx;
                    dx = oldDx * Math.cos(rotAngle) - dz * Math.sin(rotAngle);
                    dz = oldDx * Math.sin(rotAngle) + dz * Math.cos(rotAngle);
                }

                positions[i] = dx + (ox - dx) * currentFactor;
                positions[i+1] = dy + (oy - dy) * currentFactor;
                positions[i+2] = dz + (orig[i+2] - dz) * currentFactor; 
            }
            system.particles.geometry.attributes.position.needsUpdate = true;
        }

        function animate() {
            requestAnimationFrame(animate);
            currentFactor += (targetFactor - currentFactor) * 0.1;
            const time = Date.now() * 0.001;

            systems.forEach(sys => updateSystem(sys, time));

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
