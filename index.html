<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>AR ÁªàÊûÅÊâãÂäøÁâà</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; }
        #input-video { position: absolute; bottom: 20px; right: 20px; width: 120px; height: 160px; object-fit: cover; z-index: 100; transform: scaleX(-1); border: 2px solid rgba(255,255,255,0.2); border-radius: 8px; opacity: 0.8; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        
        #status-box {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            text-align: center; color: white; z-index: 20; pointer-events: none;
            background: rgba(0,0,0,0.8); padding: 20px; border-radius: 12px;
            width: 80%; max-width: 300px; font-size: 16px;
        }

        #control-panel {
            position: absolute; top: 50px; left: 10px; z-index: 50;
            background: rgba(0, 0, 0, 0.7); padding: 15px; border-radius: 8px;
            color: white; font-size: 12px; width: 220px;
            backdrop-filter: blur(4px); display: none; max-height: 70vh; overflow-y: auto;
        }
        .layer-group { border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 10px; margin-bottom: 10px; }
        .control-item { margin-bottom: 5px; }
        .control-item label { display: flex; justify-content: space-between; margin-bottom: 2px; }
        .control-item input { width: 100%; }
        
        #toggle-controls {
            position: absolute; top: 10px; left: 10px; z-index: 51;
            background: rgba(255,255,255,0.2); border: none; color: white;
            padding: 8px 12px; border-radius: 4px; cursor: pointer; font-size: 14px;
        }
        #interaction-layer { position: absolute; bottom: 30px; left: 20px; z-index: 100; }
        #hint-text { color: rgba(255,255,255,0.8); font-size: 14px; background: rgba(0,0,0,0.5); padding: 10px 20px; border-radius: 20px; cursor: pointer; border: 1px solid rgba(255,255,255,0.3); }
    </style>
</head>
<body>
    <div id="status-box">1. Ê≠£Âú®ÂàùÂßãÂåñ AR ÂºïÊìé...</div>
    <video id="input-video" playsinline></video>
    <div id="canvas-container"></div>
    <div id="interaction-layer"><div id="hint-text">üéµ ÁÇπÂáªÊí≠ÊîæÈü≥‰πê</div></div>
    <button id="toggle-controls">üõ†Ô∏è Ë∞ÉÂèÇÈù¢Êùø</button>
    <div id="control-panel"><h3 style="margin:0 0 10px 0; color:#ffd700;">Â±ÇÁ∫ßÊéßÂà∂Âô®</h3></div>
    <audio id="bgm" loop><source src="bgm.mp3" type="audio/mpeg"></audio>

    <!-- ‰ΩøÁî®ÂõΩÂÜÖÊûÅÈÄüÊ∫ê -->
    <script src="https://cdn.staticfile.org/three.js/r128/three.min.js"></script>
    <!-- MediaPipe ÂøÖÈ°ªÁî®ÂÆòÊñπÊ∫êÔºåÂ¶ÇÊûúÂç°‰ΩèËØ∑ÂºÄÊ¢ØÂ≠ê -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script>
        const LAYERS_CONFIG = [
            { file: 'pattern_inner.png',  size: 1.5, speed: 0.005, density: 90,  dispScale: 1.0, label: "Á¨¨1Â±Ç (ÂÜÖ)" },
            { file: 'pattern_outer.png',  size: 2.2, speed: 0.004, density: 100, dispScale: 1.2, label: "Á¨¨2Â±Ç" },
            { file: 'pattern_outer2.png', size: 2.9, speed: 0.003, density: 100, dispScale: 1.4, label: "Á¨¨3Â±Ç" },
            { file: 'pattern_outer3.png', size: 3.6, speed: 0.002, density: 110, dispScale: 1.6, label: "Á¨¨4Â±Ç" },
            { file: 'pattern_outer4.png', size: 4.3, speed: 0.001, density: 110, dispScale: 1.8, label: "Á¨¨5Â±Ç (Â§ñ)" }
        ];

        const statusBox = document.getElementById('status-box');
        const controlPanel = document.getElementById('control-panel');
        const toggleBtn = document.getElementById('toggle-controls');
        const hintText = document.getElementById('hint-text');
        const bgm = document.getElementById('bgm');

        // ÁîüÊàê UI
        LAYERS_CONFIG.forEach((config, index) => {
            const div = document.createElement('div');
            div.className = 'layer-group';
            div.innerHTML = `
                <div style="font-weight:bold; margin-bottom:5px; color:#aaa;">${config.label}</div>
                <div class="control-item"><label>Â§ßÂ∞è: <span id="size-val-${index}">${config.size}</span></label><input type="range" id="size-slider-${index}" min="0.5" max="6.0" step="0.1" value="${config.size}"></div>
                <div class="control-item"><label>ËΩ¨ÈÄü: <span id="speed-val-${index}">${config.speed}</span></label><input type="range" id="speed-slider-${index}" min="0" max="0.02" step="0.001" value="${config.speed}"></div>
            `;
            controlPanel.appendChild(div);
        });

        toggleBtn.addEventListener('click', () => {
            controlPanel.style.display = controlPanel.style.display === 'none' ? 'block' : 'none';
            toggleBtn.innerText = controlPanel.style.display === 'none' ? "üõ†Ô∏è Ë∞ÉÂèÇÈù¢Êùø" : "‚úñ ÂÖ≥Èó≠Èù¢Êùø";
        });

        hintText.addEventListener('click', () => {
            bgm.play().then(() => { hintText.style.display = 'none'; }).catch(() => { hintText.innerText = "Êó†Èü≥‰πê"; });
        });

        let scene, camera, renderer, systems = [], targetFactor = 0, currentFactor = 0;

        window.onload = function() { init(); };

        function init() {
            statusBox.innerText = "2. ÂêØÂä® 3D Âú∫ÊôØ...";
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 4.5; 

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true }); // alpha:true ÂÖÅËÆ∏ÈÄèÊòé
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            
            // ÈªòËÆ§ÈªëËâ≤ËÉåÊôØ
            scene.background = new THREE.Color(0x000000);

            loadLayers();
        }

        function loadLayers() {
            statusBox.innerText = "3. Ê≠£Âú®Âä†ËΩΩ 5 Âº†Á∫πÊ†∑ÂõæÁâá...";
            const loader = new THREE.TextureLoader();
            let loadedCount = 0;

            LAYERS_CONFIG.forEach((config, index) => {
                loader.load(config.file, (texture) => {
                    const sys = createLayer(texture, config.size, config.density, config.dispScale);
                    sys.rotationSpeed = config.speed;
                    sys.baseSize = config.size;
                    systems.push(sys);
                    scene.add(sys.group);

                    // ÁªëÂÆö‰∫ã‰ª∂
                    document.getElementById(`size-slider-${index}`).addEventListener('input', (e) => {
                        const newSize = parseFloat(e.target.value);
                        document.getElementById(`size-val-${index}`).innerText = newSize.toFixed(1);
                        const scale = newSize / sys.baseSize;
                        sys.group.scale.set(scale, scale, 1);
                        sys.group.position.z = (6.0 - newSize) * 0.05;
                    });
                    document.getElementById(`speed-slider-${index}`).addEventListener('input', (e) => {
                        sys.rotationSpeed = parseFloat(e.target.value);
                        document.getElementById(`speed-val-${index}`).innerText = sys.rotationSpeed.toFixed(3);
                    });

                    loadedCount++;
                    if (loadedCount === LAYERS_CONFIG.length) {
                        statusBox.innerText = "4. ÂõæÁâáÂÖ®ÈÉ®Âä†ËΩΩÂÆåÊàêÔºåÂêØÂä® AI...";
                        startCamera();
                    }
                }, undefined, () => {
                    statusBox.innerHTML += `<br>‚ùå Â§±Ë¥•: ${config.file}`;
                });
            });
        }

        function createLayer(texture, size, density, disperseScale) {
            const systemObj = { group: new THREE.Group(), mesh: null, particles: null, origPos: null, dispPos: null };
            
            const planeGeo = new THREE.PlaneGeometry(size, size);
            const planeMat = new THREE.MeshBasicMaterial({ map: texture, transparent: true, opacity: 0, depthWrite: false, side: THREE.DoubleSide });
            systemObj.mesh = new THREE.Mesh(planeGeo, planeMat);
            systemObj.group.add(systemObj.mesh);

            const img = texture.image;
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = density; canvas.height = density;
            ctx.drawImage(img, 0, 0, density, density);
            const data = ctx.getImageData(0, 0, density, density).data;

            const validPositions = [], validColors = [];
            for(let i = 0; i < density * density; i++) {
                const r = data[i*4], g = data[i*4+1], b = data[i*4+2], a = data[i*4+3];
                if (a > 50) { 
                    const x = i % density, y = Math.floor(i / density);
                    validPositions.push((x/density-0.5)*size, -(y/density-0.5)*size, 0);
                    validColors.push(r/255*1.2, g/255*1.2, b/255*1.2);
                }
            }

            const count = validPositions.length / 3;
            const geometry = new THREE.BufferGeometry();
            systemObj.origPos = new Float32Array(validPositions);
            systemObj.dispPos = new Float32Array(count * 3);
            const colors = new Float32Array(validColors);

            for(let i = 0; i < count * 3; i+=3) {
                const r = (0.5 + Math.random() * 2.5) * disperseScale; 
                const angle = Math.random() * Math.PI * 2; 
                const h = (Math.random() - 0.5) * 4 * disperseScale; 
                const twist = h * 2.0; 
                systemObj.dispPos[i] = r * Math.cos(angle + twist);     
                systemObj.dispPos[i+1] = h + 1.0;                       
                systemObj.dispPos[i+2] = r * Math.sin(angle + twist);   
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(systemObj.dispPos.slice(), 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            systemObj.particles = new THREE.Points(geometry, new THREE.PointsMaterial({
                size: 0.018, vertexColors: true, transparent: true, opacity: 0.95, blending: THREE.AdditiveBlending, depthWrite: false
            }));
            systemObj.group.add(systemObj.particles);
            systemObj.group.position.z = (6.0 - size) * 0.05; 
            return systemObj;
        }

        function startCamera() {
            const videoElement = document.getElementById('input-video');
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            hands.setOptions({ maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
            
            hands.onResults(results => {
                if (statusBox.style.display !== 'none') statusBox.style.display = 'none';
                let newTarget = 0; 
                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    const lm = results.multiHandLandmarks[0];
                    const dist = Math.sqrt(Math.pow(lm[4].x - lm[8].x, 2) + Math.pow(lm[4].y - lm[8].y, 2));
                    if (dist < 0.05) newTarget = 1; 
                } 
                targetFactor = newTarget;
            });

            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => { await hands.send({image: videoElement}); },
                width: 640, height: 480
            });
            cameraUtils.start().catch(err => statusBox.innerText = "‚ùå ÊëÑÂÉèÂ§¥ÊùÉÈôêË¢´ÊãíÔºåËØ∑Âà∑Êñ∞ÂÖÅËÆ∏");
            animate();
        }

        function updateSystem(system, time) {
            if (!system.particles) return;
            system.group.rotation.z -= system.rotationSpeed;

            if (currentFactor > 0.8) {
                let alpha = (currentFactor - 0.8) * 5;
                if(alpha > 1) alpha = 1;
                system.mesh.material.opacity = alpha;
                system.particles.material.opacity = 0.95 * (1 - alpha);
            } else {
                system.mesh.material.opacity = 0;
                system.particles.material.opacity = 0.95;
            }

            system.particles.material.size = 0.028 - (currentFactor * 0.012);
            const positions = system.particles.geometry.attributes.position.array;
            const orig = system.origPos;
            const disp = system.dispPos;

            for(let i = 0; i < positions.length; i+=3) {
                const ox = orig[i], oy = orig[i+1]; 
                let dx = disp[i], dy = disp[i+1], dz = disp[i+2];
                if (currentFactor < 0.8) {
                    const rotAngle = time * 0.5; 
                    const oldDx = dx;
                    dx = oldDx * Math.cos(rotAngle) - dz * Math.sin(rotAngle);
                    dz = oldDx * Math.sin(rotAngle) + dz * Math.cos(rotAngle);
                }
                positions[i] = dx + (ox - dx) * currentFactor;
                positions[i+1] = dy + (oy - dy) * currentFactor;
                positions[i+2] = dz + (orig[i+2] - dz) * currentFactor; 
            }
            system.particles.geometry.attributes.position.needsUpdate = true;
        }

        function animate() {
            requestAnimationFrame(animate);
            currentFactor += (targetFactor - currentFactor) * 0.1;
            const time = Date.now() * 0.001;
            systems.forEach(sys => updateSystem(sys, time));
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
