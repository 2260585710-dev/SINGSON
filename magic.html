<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ç³»ç»Ÿè‡ªæ£€ç‰ˆ</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; }
        #info {
            position: absolute; top: 50%; left: 50%; 
            transform: translate(-50%, -50%);
            color: #fff; text-align: center; pointer-events: none;
            background: rgba(0,0,0,0.5); padding: 20px; border-radius: 10px;
        }
    </style>
    <script src="https://unpkg.com/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
</head>
<body>

    <div id="info">
        <h3>ğŸ” æ­£åœ¨ç”Ÿæˆæµ‹è¯•å›¾æ¡ˆ...</h3>
        <p id="sub">å¦‚æœä¸æ˜¾ç¤ºï¼Œè¯´æ˜æ‰‹æœºä¸æ”¯æŒé«˜ç²¾åº¦</p>
    </div>
    <video class="input_video" style="display:none"></video>

    <script>
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 120;

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        let particles;
        let originalPositions = [];
        let randomTargets = [];
        let handOpenness = 0;

        // --- ğŸ”´ å…³é”®ç‚¹ï¼šæˆ‘ä»¬ä¸è¯»å›¾ç‰‡ï¼Œç›´æ¥ç”¨ä»£ç ç”»ä¸€ä¸ª ---
        function createTestPattern() {
            // åˆ›å»ºä¸€ä¸ªè™šæ‹Ÿç”»å¸ƒ
            const canvas = document.createElement('canvas');
            canvas.width = 300; // é™ä½åˆ†è¾¨ç‡ä¿å¹³å®‰
            canvas.height = 300;
            const ctx = canvas.getContext('2d');

            // ç”»ä¸€ä¸ªå½©è™¹æ¸å˜åœ†
            const gradient = ctx.createRadialGradient(150, 150, 20, 150, 150, 150);
            gradient.addColorStop(0, "white");
            gradient.addColorStop(0.3, "gold");
            gradient.addColorStop(0.6, "red");
            gradient.addColorStop(1, "blue");
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(150, 150, 120, 0, Math.PI * 2);
            ctx.fill();
            
            // å†™ä¸ªå­—
            ctx.fillStyle = "white";
            ctx.font = "bold 60px Arial";
            ctx.textAlign = "center";
            ctx.fillText("TEST", 150, 170);

            return ctx.getImageData(0, 0, 300, 300).data;
        }

        // ç”Ÿæˆç²’å­
        try {
            const data = createTestPattern();
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            const width = 300;
            const height = 300;

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const i = (y * width + x) * 4;
                    const alpha = data[i + 3];

                    if (alpha > 50) {
                        const pX = (x - width / 2);
                        const pY = -(y - height / 2);
                        const pZ = 0;

                        positions.push(pX, pY, pZ);
                        originalPositions.push(pX, pY, pZ);
                        randomTargets.push((Math.random()-0.5)*300, (Math.random()-0.5)*300, (Math.random()-0.5)*300);

                        colors.push(data[i]/255, data[i+1]/255, data[i+2]/255);
                    }
                }
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            const material = new THREE.PointsMaterial({
                size: 1.0, 
                vertexColors: true,
                transparent: true,
                opacity: 0.9,
                depthTest: false
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);
            
            document.getElementById('info').style.display = 'none'; // éšè—åŠ è½½å­—

        } catch (e) {
            document.getElementById('sub').innerText = "é”™è¯¯: " + e.message;
        }

        // åŠ¨ç”»
        function animate() {
            requestAnimationFrame(animate);
            if (particles) {
                const pos = particles.geometry.attributes.position.array;
                // è‡ªåŠ¨æ¼”ç¤ºï¼šå¦‚æœæ²¡æœ‰æ‰‹åŠ¿ï¼Œå°±è‡ªåŠ¨å‘¼å¸
                let factor = handOpenness;
                if (factor === 0) factor = Math.sin(Date.now() * 0.002) * 0.5 + 0.5;

                for (let i = 0; i < pos.length; i += 3) {
                    const tx = originalPositions[i] + (randomTargets[i] - originalPositions[i]) * factor;
                    const ty = originalPositions[i+1] + (randomTargets[i+1] - originalPositions[i+1]) * factor;
                    const tz = originalPositions[i+2] + (randomTargets[i+2] - originalPositions[i+2]) * factor;
                    pos[i] += (tx - pos[i]) * 0.1;
                    pos[i+1] += (ty - pos[i+1]) * 0.1;
                    pos[i+2] += (tz - pos[i+2]) * 0.1;
                }
                particles.geometry.attributes.position.needsUpdate = true;
                particles.rotation.y += 0.005;
            }
            renderer.render(scene, camera);
        }
        animate();

        // å°è¯•åŠ è½½æ‰‹åŠ¿
        try {
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            hands.setOptions({maxNumHands: 1, modelComplexity: 0});
            hands.onResults((results) => {
                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    const lm = results.multiHandLandmarks[0];
                    const dist = Math.sqrt(Math.pow(lm[4].x - lm[8].x, 2) + Math.pow(lm[4].y - lm[8].y, 2));
                    handOpenness = Math.max(0, Math.min(1, (dist - 0.04) * 3));
                } else { handOpenness = 0; }
            });
            const video = document.getElementsByClassName('input_video')[0];
            const cameraUtils = new Camera(video, {
                onFrame: async () => { await hands.send({image: video}); },
                width: 640, height: 480
            });
            cameraUtils.start();
        } catch(e){}
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
