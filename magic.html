<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>çº¹æ ·ç²’å­äº¤äº’ç³»ç»Ÿ</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; }
        
        /* UI é¢æ¿æ ·å¼ */
        #ui-container {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            z-index: 100;
            width: 200px;
        }
        
        h3 { margin: 0 0 15px 0; font-size: 16px; letter-spacing: 1px; }
        
        .control-group { margin-bottom: 15px; }
        label { display: block; margin-bottom: 5px; font-size: 12px; color: #aaa; }
        
        /* é¢œè‰²é€‰æ‹©å™¨ */
        input[type="color"] {
            width: 100%;
            height: 40px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            background: none;
        }

        /* å…¨å±æŒ‰é’® */
        #fullscreen-btn {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 30px;
            backdrop-filter: blur(5px);
            cursor: pointer;
            z-index: 100;
            font-size: 14px;
        }
        
        /* åŠ è½½æç¤º */
        #loading {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            pointer-events: none;
            transition: opacity 0.5s;
        }

        /* éšè—æ‘„åƒå¤´ç”»é¢ï¼ˆæˆ‘ä»¬åªéœ€è¦æ•°æ®ï¼Œä¸éœ€è¦çœ‹ç”»é¢ï¼‰ */
        .input_video { display: none; }
    </style>
    
    <!-- å¼•å…¥ Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- å¼•å…¥ MediaPipe Hands (æ‰‹åŠ¿è¯†åˆ«) -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
</head>
<body>

    <!-- UI é¢æ¿ -->
    <div id="ui-container">
        <h3>âœ¨ çº¹æ ·ç²’å­æ§åˆ¶</h3>
        
        <div class="control-group">
            <label>ç²’å­é¢œè‰² (Tint)</label>
            <input type="color" id="colorPicker" value="#ffffff">
        </div>
        
        <div class="control-group">
            <label>å½“å‰çŠ¶æ€</label>
            <div id="status-text" style="color: #00ff00; font-size: 14px;">ç­‰å¾…æ‘„åƒå¤´...</div>
        </div>
        
        <p style="font-size: 10px; color: #666;">
            æç¤ºï¼š<br>
            ğŸ‘‹ å¼ å¼€æ‰‹æŒ -> ç²’å­æ‰©æ•£<br>
            âœŠ æåˆ/æ¡æ‹³ -> ç²’å­èšæ‹¢
        </p>
    </div>

    <button id="fullscreen-btn">â›¶ å…¨å±ä½“éªŒ</button>
    <div id="loading">æ­£åœ¨å¯åŠ¨ AI å¼•æ“...</div>
    
    <!-- éšè—çš„è§†é¢‘å…ƒç´ ç”¨äºAIåˆ†æ -->
    <video class="input_video"></video>

    <script>
        // 1. åˆå§‹åŒ– Three.js åœºæ™¯
        const scene = new THREE.Scene();
        // æ·»åŠ ä¸€ç‚¹é›¾åŒ–æ•ˆæœï¼Œè®©è¿œå¤„ç²’å­æ·¡å‡º
        scene.fog = new THREE.FogExp2(0x000000, 0.001);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 50;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // 2. åˆ›å»ºç²’å­ç³»ç»Ÿ
        let particles;
        const particleCount = 2000; // ç²’å­æ•°é‡
        const geometry = new THREE.BufferGeometry();
        const positions = [];
        const velocities = []; // è®°å½•æ¯ä¸ªç²’å­çš„é€Ÿåº¦
        const originalPositions = []; // è®°å½•åŸå§‹ä½ç½®

        // åˆå§‹åŒ–ç²’å­ä½ç½®ï¼ˆéšæœºåˆ†å¸ƒåœ¨ä¸€ä¸ªçƒä½“å†…ï¼‰
        for (let i = 0; i < particleCount; i++) {
            const x = (Math.random() - 0.5) * 60;
            const y = (Math.random() - 0.5) * 60;
            const z = (Math.random() - 0.5) * 60;
            positions.push(x, y, z);
            originalPositions.push(x, y, z);
            velocities.push(0, 0, 0);
        }

        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));

        // åŠ è½½ä½ çš„çº¹æ ·å›¾ç‰‡ä½œä¸ºç²’å­æè´¨
        const textureLoader = new THREE.TextureLoader();
        // è¿™é‡Œç›´æ¥ç”¨ä½ ä»“åº“é‡Œçš„ overlay.png
        const particleTexture = textureLoader.load('./overlay.png');

        const material = new THREE.PointsMaterial({
            size: 1.5, // ç²’å­å¤§å°
            map: particleTexture,
            transparent: true,
            opacity: 0.8,
            color: 0xffffff,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });

        particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // 3. åŠ¨ç”»ä¸æ‰‹åŠ¿äº¤äº’å˜é‡
        let handOpenness = 0; // 0 = é—­åˆ, 1 = å¼ å¼€
        let targetSpread = 1; // ç›®æ ‡æ‰©æ•£ç¨‹åº¦
        
        // 4. MediaPipe æ‰‹åŠ¿è¯†åˆ«è®¾ç½®
        const videoElement = document.getElementsByClassName('input_video')[0];
        const statusText = document.getElementById('status-text');
        const loadingText = document.getElementById('loading');

        function onResults(results) {
            loadingText.style.opacity = 0; // éšè—åŠ è½½æç¤º
            
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                statusText.innerText = "å·²æ£€æµ‹åˆ°æ‰‹æŒ âœ¨";
                
                // è·å–ç¬¬ä¸€åªæ‰‹
                const landmarks = results.multiHandLandmarks[0];
                
                // è®¡ç®—å¤§æ‹‡æŒ‡æŒ‡å°–(4)å’Œé£ŸæŒ‡æŒ‡å°–(8)çš„è·ç¦»
                const thumbTip = landmarks[4];
                const indexTip = landmarks[8];
                
                // ç®€å•çš„è·ç¦»è®¡ç®—
                const distance = Math.sqrt(
                    Math.pow(thumbTip.x - indexTip.x, 2) + 
                    Math.pow(thumbTip.y - indexTip.y, 2)
                );

                // æ˜ å°„è·ç¦»åˆ° 0-1 ä¹‹é—´ (æ ¹æ®ç»éªŒè°ƒæ•´é˜ˆå€¼)
                // è·ç¦»é€šå¸¸åœ¨ 0.05 (æåˆ) åˆ° 0.3 (å¼ å¼€) ä¹‹é—´
                let openness = (distance - 0.05) * 5; 
                openness = Math.max(0, Math.min(1, openness)); // é™åˆ¶åœ¨0åˆ°1ä¹‹é—´
                
                handOpenness = openness;

            } else {
                statusText.innerText = "æœªæ£€æµ‹åˆ°æ‰‹æŒ...";
                // å¦‚æœæ²¡æ‰‹ï¼Œé»˜è®¤ç¼“æ…¢å‘¼å¸æ•ˆæœ
                handOpenness = 0.5 + Math.sin(Date.now() * 0.002) * 0.2;
            }
        }

        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 640,
            height: 480
        });
        cameraUtils.start();

        // 5. æ¸²æŸ“å¾ªç¯
        function animate() {
            requestAnimationFrame(animate);

            // ç²’å­ç³»ç»Ÿæ—‹è½¬
            particles.rotation.y += 0.002;
            particles.rotation.x += 0.001;

            // æ ¹æ®æ‰‹åŠ¿è°ƒæ•´æ‰©æ•£èŒƒå›´
            // å¦‚æœæ‰‹å¼ å¼€ï¼Œæ‰©æ•£ç³»æ•°å˜å¤§ï¼›æ‰‹æåˆï¼Œå˜å°
            const targetScale = 1 + (handOpenness * 3); // æœ€å¤§æ”¾å¤§3å€
            
            const positions = particles.geometry.attributes.position.array;
            
            for (let i = 0; i < particleCount; i++) {
                const ix = i * 3;
                const iy = i * 3 + 1;
                const iz = i * 3 + 2;

                // ç›®æ ‡ä½ç½®ï¼šåŸå§‹ä½ç½® * ç¼©æ”¾ç³»æ•°
                const tx = originalPositions[i] * targetScale;
                const ty = originalPositions[i] * targetScale;
                const tz = originalPositions[i] * targetScale;

                // ç®€å•çš„çº¿æ€§æ’å€¼åŠ¨ç”» (Lerp) è®©è¿åŠ¨æ›´å¹³æ»‘
                positions[ix] += (tx - positions[ix]) * 0.05;
                positions[iy] += (ty - positions[iy]) * 0.05;
                positions[iz] += (tz - positions[iz]) * 0.05;
            }
            
            particles.geometry.attributes.position.needsUpdate = true;

            renderer.render(scene, camera);
        }

        animate();

        // 6. äº¤äº’åŠŸèƒ½
        // é¢œè‰²é€‰æ‹©
        document.getElementById('colorPicker').addEventListener('input', (e) => {
            particles.material.color.set(e.target.value);
        });

        // å…¨å±æ§åˆ¶
        document.getElementById('fullscreen-btn').addEventListener('click', () => {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
            }
        });

        // çª—å£å¤§å°è°ƒæ•´
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
