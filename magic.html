<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>çº¹æ ·ç²’å­ (ç¨³å¥ç‰ˆ)</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; }
        #loading {
            position: absolute; top: 50%; left: 50%; 
            transform: translate(-50%, -50%);
            color: #ffd700; font-size: 14px;
            pointer-events: none;
        }
        .input_video { display: none; }
    </style>
    <!-- ä½¿ç”¨ç¨³å®šçš„ CDN -->
    <script src="https://unpkg.com/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
</head>
<body>

    <div id="loading">æ­£åœ¨åŠ è½½çº¹æ ·...</div>
    <video class="input_video"></video>

    <script>
        // -----------------------------------------------------------
        // ğŸ”´ å…³é”®æ­¥éª¤ï¼šæŠŠä½ çš„ Base64 å­—ç¬¦ç²˜è´´åœ¨ä¸‹é¢å¼•å·é‡Œï¼
        // ç›®å‰è¿™é‡Œæ”¾çš„æ˜¯ä¸€ä¸ªé€æ˜çš„å ä½ç¬¦ï¼Œè¯·ä½ æ›¿æ¢æˆä½ çš„å›¾ç‰‡ä»£ç 
        // -----------------------------------------------------------
        const myImageBase64 = "./overlay.png"; 
        // ğŸ‘† å¦‚æœä½ æœ‰ Base64ï¼ŒæŠŠ "./overlay.png" åˆ æ‰ï¼Œæ¢æˆé‚£ä¸€å¤§ä¸²å­—ç¬¦
        // å¦‚æœæ²¡æœ‰ï¼Œå…ˆä¿æŒ "./overlay.png"ï¼Œæˆ‘ä»¬å†èµŒä¸€æ¬¡æœ¬åœ°åŠ è½½
        
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 150;

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        let particles;
        let originalPositions = [];
        let randomTargets = [];
        let handOpenness = 0;

        // åŠ è½½å›¾ç‰‡
        const img = new Image();
        img.crossOrigin = "Anonymous";
        img.src = myImageBase64; 

        img.onload = function() {
            document.getElementById('loading').innerText = "ç”Ÿæˆç²’å­ä¸­...";
            
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const targetWidth = 200; // é™ä½ä¸€ç‚¹åˆ†è¾¨ç‡ä¿å¹³å®‰
            const scale = targetWidth / img.width;
            canvas.width = targetWidth;
            canvas.height = img.height * scale;
            
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            const data = ctx.getImageData(0, 0, canvas.width, canvas.height).data;

            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            const baseColor = new THREE.Color(0xffd700); // è¿˜æ˜¯ç”¨é‡‘è‰²ï¼Œæ¯”è¾ƒç¨³

            for (let y = 0; y < canvas.height; y++) {
                for (let x = 0; x < canvas.width; x++) {
                    const i = (y * canvas.width + x) * 4;
                    if (data[i + 3] > 50) { // åªå–ä¸é€æ˜çš„ç‚¹
                        const pX = (x - canvas.width / 2) * 1.5;
                        const pY = -(y - canvas.height / 2) * 1.5;
                        positions.push(pX, pY, 0);
                        originalPositions.push(pX, pY, 0);
                        randomTargets.push((Math.random()-0.5)*300, (Math.random()-0.5)*300, (Math.random()-0.5)*300);
                        
                        colors.push(baseColor.r, baseColor.g, baseColor.b);
                    }
                }
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            const material = new THREE.PointsMaterial({
                size: 1.2,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                transparent: true
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);
            document.getElementById('loading').style.display = 'none';
        };

        img.onerror = function() {
            document.getElementById('loading').innerText = "å›¾ç‰‡åˆåŠ è½½å¤±è´¥äº†...è¯·ç¡®è®¤è·¯å¾„æˆ–ä½¿ç”¨Base64";
            document.getElementById('loading').style.color = "red";
        }

        // åŠ¨ç”»
        function animate() {
            requestAnimationFrame(animate);
            if (particles) {
                const pos = particles.geometry.attributes.position.array;
                // å¦‚æœæ‰‹åŠ¿æ²¡åŠ è½½å‡ºæ¥ï¼Œå…ˆè‡ªåŠ¨åŠ¨ä¸€åŠ¨ï¼Œè¯æ˜æ²¡æ­»æœº
                const autoPulse = Math.sin(Date.now() * 0.002) * 0.5 + 0.5;
                const factor = (handOpenness > 0) ? handOpenness : 0; // æš‚æ—¶åªå“åº”æ‰‹åŠ¿

                for (let i = 0; i < pos.length; i += 3) {
                    const tx = originalPositions[i] + (randomTargets[i] - originalPositions[i]) * factor;
                    const ty = originalPositions[i+1] + (randomTargets[i+1] - originalPositions[i+1]) * factor;
                    const tz = originalPositions[i+2] + (randomTargets[i+2] - originalPositions[i+2]) * factor;
                    
                    pos[i] += (tx - pos[i]) * 0.1;
                    pos[i+1] += (ty - pos[i+1]) * 0.1;
                    pos[i+2] += (tz - pos[i+2]) * 0.1;
                }
                particles.geometry.attributes.position.needsUpdate = true;
                particles.rotation.y += 0.005;
            }
            renderer.render(scene, camera);
        }
        animate();

        // å°è¯•åŠ è½½æ‰‹åŠ¿ (å¦‚æœåœ¨å›½å†…å¯èƒ½æ¯”è¾ƒæ…¢ï¼Œä¸å¼ºæ±‚)
        try {
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            hands.setOptions({maxNumHands: 1, modelComplexity: 0}); // ç”¨æœ€ç®€å•çš„æ¨¡å‹ï¼ŒåŠ è½½å¿«
            hands.onResults((results) => {
                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    const lm = results.multiHandLandmarks[0];
                    const dist = Math.sqrt(Math.pow(lm[4].x - lm[8].x, 2) + Math.pow(lm[4].y - lm[8].y, 2));
                    handOpenness = Math.max(0, Math.min(1, (dist - 0.04) * 3));
                }
            });
            
            const video = document.getElementsByClassName('input_video')[0];
            const cameraUtils = new Camera(video, {
                onFrame: async () => { await hands.send({image: video}); },
                width: 640, height: 480
            });
            cameraUtils.start();
        } catch(e) {
            console.log("æ‰‹åŠ¿åº“åŠ è½½å¤±è´¥ï¼Œä»…å±•ç¤ºåŠ¨ç”»");
        }
        
    </script>
</body>
</html>
